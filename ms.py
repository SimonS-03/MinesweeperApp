from tkinter import *
from tkinter import messagebox
from random import randint, uniform
import time


class Tile:
    """Contains information about a single tile/square in the minefield"""
    def __init__(self, coord: tuple, mined = False, flagged = False, scored = False):
        self.coord = coord
        self.mined = mined
        self.flagged = flagged
        self.scored = scored
    
    
    def flag(self, button: Frame): 
        """Flags or unflags the tile (changes self.flagged) to true if false and false if true """
        if not self.flagged:
            self.flagged = True
            button.configure(bg = "orange")

        else:
            self.flagged = False
            button.configure(bg = "#303030")


class Minefield:
    """Contains information and methods in order to create a minefield"""
    def __init__(self, game_controller,bombcount: int = None, grid_width: int = None, grid_height: int = None) -> None:
        self.GC: Game_controller = game_controller
        self.bombcount = bombcount
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.cleared_coordinates = []
        self.tiles: dict(Tile) = {}
    
    def create_tilemap(self, safe_coord: tuple) -> None:
        """Adds a series of Tile objects to the self.tiles dictionary, adds mines to random tile objects in this dictionary so long as the coordinates for the tile
        are not part of a list of safe coordinates generated by the get_safe_coords function."""
        
        def get_safe_coords () -> list:
            """Creates a list of coords around a coordinate where all tiles are safe from mines. Meant to be used after the first click of the level."""
            nonlocal safe_coord

            safe_tile_count = int(self.grid_width * self.grid_height * uniform(0.07, 0.12))
            #If the bombs dont fit with current numer of guaranteed safe tiles (should rarely trigger though)
            while (self.grid_width * self.grid_height - safe_tile_count < self.bombcount):
                safe_tile_count = int(self.grid_width * self.grid_height * uniform(0, 0.12))

            safe_coords = [safe_coord]
            for i in range (safe_tile_count):
                #Get random existing safe zone coordinate
                random_safe_coord = safe_coords[randint(0, len(safe_coords) - 1)]
                new_coord = (random_safe_coord[0] + randint(-1, 1), random_safe_coord[1] + randint(-1, 1))

                #Loops through creating coordinates that are allowed (not outside of grid and no duplicates)
                while new_coord in safe_coords or new_coord[0] == 0 or new_coord[0] > self.grid_width or new_coord[1] == 0 or new_coord[1] > self.grid_height:
                    random_safe_coord = safe_coords[randint(0, len(safe_coords) - 1)]
                    new_coord = (random_safe_coord[0] + randint(-1, 1), random_safe_coord[1] + randint(-1, 1))
                safe_coords.append(new_coord)
            #print(safe_coords)
            return safe_coords

        self.tiles = {}
        #Creating "empty" minefield (default options in tile class is non-mined)
        for i in range (1, self.grid_width + 1):
            for j in range (1, self.grid_height + 1):
                self.tiles[(i, j)] = Tile((i, j))
        
        #Adding bombs
        bomb_coords = []
        safe_zone_coords = get_safe_coords()
        for i in range(self.bombcount):
            random_coords = (randint(1, self.grid_width), randint(1, self.grid_height))
            
            #Avoiding duplicates and placing mines on safe zone coordinates
            while random_coords in bomb_coords or random_coords in safe_zone_coords:
                random_coords = (randint(1, self.grid_width), randint(1, self.grid_height))
            
            bomb_coords.append(random_coords)
            self.tiles[random_coords].mined = True 
        

class Scoreboard:
    """Contains methods in order to add and read scoreboard data from a text file"""
    def __init__(self, game_controller,file: str = "scoreboard.txt") -> None:
        self.file = file
        self.GC: Game_controller = game_controller
    def sort(self, linelist: list) -> list:
        """Sorts the scoreboard data into sorted list (lowest time furthest at lowest index). Returns that list."""
        data_dict = {}

        for i in range(len(linelist)):
            split = linelist[i].split()
            #info about level played and name as key. Value is time.
            data_dict[f"{split[0]} {split[1]} {split[2]}"] = round(float(split[3]), 2)
        
        time_list = list(data_dict.values())
        
        time_list.sort()
        key_list = list(data_dict.keys())

        sorted_complete_list = []

        for i in range(len(time_list)):
            for k in range (len(key_list)):
                if data_dict[key_list[k]] == time_list[i]:
                    
                    if f"{key_list[k]} {time_list[i]}" not in sorted_complete_list:
                        sorted_complete_list.append(f"{key_list[k]} {time_list[i]}")
                        #break   
        return sorted_complete_list
        
    def read(self, lines):
        """Takes an amount of lines (int) to read from file and returns these with new lines inbetween"""
        scoreboard = open(self.file, "r")
        minefield = self.GC.minefield
        scores = scoreboard.readlines()

        wanted_scores = []
        scores_counted = 0
        for i in range (len(scores)):    
            if f"{minefield.grid_width}x{minefield.grid_height} {minefield.bombcount}" in scores[i] and scores_counted < lines:
                temp_split = scores[i].split()
                time_formated = time.strftime("%H:%M:%S", time.gmtime(float(temp_split[3])))
                wanted_scores.append(f"{temp_split[2]} {time_formated}")
                scores_counted += 1
        
        readable_info = "\n".join(wanted_scores)
        return readable_info

    def add(self):
        """Adds a datapoint to the file (in this case scoreboard.txt). Checks if name is already in the file and avoids reducing highscore if a previous score from
        the same name was better."""
        file_read = open("scoreboard.txt", "r")
        linelist = file_read.readlines()
        name_found = False
        time = self.GC.scorekeeper.time_finish - self.GC.scorekeeper.time_start
        if len(linelist) > 0:
            for i in range (len(linelist)):
                #The format of the score text file will be "{gridsize_x}x{gridsize_y} {bombcount} {name} {time}" 
                if f"{self.GC.scorekeeper.name}" in linelist[i] and f"{self.GC.minefield.grid_width}x{self.GC.minefield.grid_height}" in linelist[i] and f"{self.GC.minefield.bombcount}" in linelist[i]:
                    name_found = True
                    prev_data = linelist[i].split()
                    #print(prev_data)
                    prev_time = float(prev_data[3])
                    if prev_time > time:
                        linelist[i] = f"{self.GC.minefield.grid_width}x{self.GC.minefield.grid_height} {self.GC.minefield.bombcount} {self.GC.scorekeeper.name} {time}"
        
        if not name_found:
            linelist.append(f"{self.GC.minefield.grid_width}x{self.GC.minefield.grid_height} {self.GC.minefield.bombcount} {self.GC.scorekeeper.name} {time}")
        
        file_read.close()
        
        sorted_list = self.sort(linelist)

        finished_text = "\n".join(sorted_list)
    
        file_write = open("scoreboard.txt", "w")
        file_write.write(finished_text)
        file_write.close()
    

class GUI:
    """Contains information and methods pertaining to what is being displayed on screen"""
    def __init__(self, width: int, height: int, current: Frame = None, game_frame: Frame = None, menu_frame: Frame = None, game_controller = None) -> None:
        #Sets up the root window
        self.root = Tk()
        self.width = width
        self.height = height
        self.root.geometry(f"{width}x{height}")

        #Contains the game and menu frame and info on which one is being displayed
        self.current = current
        self.game_frame = game_frame
        self.menu_frame = menu_frame
        
        #In order to call functions needing other objects data and methods
        self.GC: Game_controller = game_controller
   
        

    
    def change_size(self, width: int, height: int) -> None:
        """Change size of root window."""
        self.width = width
        self.height = height
        self.root.geometry(f"{self.width}x{self.height}")
    
    def set_current(self, new_frame: str):
        """Change current frame shown to user, new_frame should belong to ["game", "menu"]"""
        if self.current != None:
            self.current.pack_forget()
        
        if new_frame == "game":
            self.game_frame.pack(side = TOP, expand=True, fill="both")
            self.current = self.game_frame
        elif new_frame == "menu":
            self.menu_frame.pack(side = TOP, expand=True, fill="both")
            self.current = self.menu_frame

    def create_game_frame(self) -> None:
        """Creates all the GUI elements of the window containing the minesweeping component of the game and a restart and back-to-menu button."""
        #Sets up two frames, game_frame containing everything the game needs and current_grid_frame only contains the grid with buttons.
        game_frame = Frame(self.root, background="#121212", height = self.height, width = self.width)
        current_grid_frame: Frame
        
        #Creates a back to menu and retry button
        back_to_menu = Button(game_frame, height = 2, width = 15, text = "Back to menu", font = ("Helvetica", 20), command = lambda: self.set_current("menu"))
        back_to_menu.pack(side = TOP, anchor = NW)

        def restart():
            """Resets just the grid frame in order avoid remaking the entire game window. Also call a functions which reset the score data about the previous game."""
            nonlocal current_grid_frame
            self.GC.reset_score()
            current_grid_frame.destroy()
            create_button_grid()

        restart_button = Button(game_frame, height = 2, width = 15, text = "Restart", font = ("Helvetica", 20), command = lambda: restart())
        restart_button.pack(side = TOP, anchor = NW)
        
        def create_button_grid () -> None:
            """Creates a grid of buttons (frame widgets) all corresponding to a Tile object, they are bound to check for bomb (mouse 1) or flag (mouse 2)."""
            nonlocal current_grid_frame

            current_grid_frame = Frame(game_frame)
            current_grid_frame.pack(side = BOTTOM, pady = 0.01*self.height)
            button_dict = {}
            first_click = True
            
            def call_tile_clear(event, coordinates: tuple, button: Frame, button_dict: dict):
                """If it is the first click on a tile, then creates the underlying minefield with the coordinates clicked as safe coordinates.
                Otherwise just passes the function call on to the game controller which clears it and updates all other objects."""
                nonlocal first_click
                if first_click:
                    self.GC.minefield.create_tilemap(coordinates)
                    #Takes time at first click in order to compare it when the game ends.
                    self.GC.scorekeeper.time_start = time.time()
                    first_click = False

                self.GC.clear_tile(coordinates, button_dict)
            
            def flag_tile(event, coordinates: tuple, button: Frame):
                """Flags a given button, function necessary to contain event parameter."""
                self.GC.minefield.tiles[coordinates].flag(button)

            #Largest square buttonsize that still fits
            button_size = min([self.width, self.height]) * 0.75// max([self.GC.minefield.grid_width, self.GC.minefield.grid_height])
            #Creates all buttons and adding them to current_grid_frame
            for i in range(self.GC.minefield.grid_width):
                for j in range(self.GC.minefield.grid_height):           
                    
                    button_dict[(i + 1, j + 1)] = Frame(current_grid_frame, height = button_size, width = button_size, bg = "#303030", highlightbackground="#181818", highlightthickness= 2)
                    
                    call_flag = lambda event, i=i, j=j, button=button_dict[(i + 1, j + 1)]: flag_tile(event, (i+1, j+1), button)
                    call_bombcheck = lambda event, i=i, j=j: call_tile_clear(event, (i+1, j+1), button_dict[(i+1, j+1)], button_dict)

                    button_dict[(i + 1, j + 1)].grid(row = j, column = i)
                    button_dict[(i + 1, j + 1)].bind('<Button-1>', call_bombcheck)
                    button_dict[(i + 1, j + 1)].bind('<Button-2>', call_flag)
                    button_dict[(i + 1, j + 1)].pack_propagate(False)
            return None
        
        create_button_grid()

        #Replaces and removes previous instance of a game frame (save memory)
        if self.game_frame != None:
            self.game_frame.destroy()
            self.game_frame = game_frame
        else:
            self.game_frame = game_frame    


    def create_menu_frame(self) -> None:
        """Creates all the GUI components that the a menu window will need; infields for settings, labels for information and a button that starts the game"""
        menu_frame = Frame(self.root, background="#121212", height = self.height, width = self.width)
        menu_frame.pack(expand=True, fill="both")
        
        #Creating text infields where settings about the game can be entered (or left empty)
        IF_list = []; lbl_list = []
        text_list = ["window size:", "width of grid:", "height of grid:", "bombcount:", "name:"]
        for i in range(5):
            temp_IF = Entry(menu_frame, font = ("Helvetica", 24))
            temp_IF.place(x = self.width - 160, y = i*40, width = 160)
            temp_lbl = Label(menu_frame, font = ("Helvetica, 24"), text = text_list[i])
            temp_lbl.place(x = self.width - 320, y = i*40)
            
            IF_list.append(temp_IF); lbl_list.append(temp_lbl)

        
        def start_game_GUI() -> None:
            """Starts the GUI with entered settings in the text-infields (entries)"""
            nonlocal IF_list
            #standard values (if nothing else is entered)
            window_size = self.width; bombcount = 25; gridsize_x = 12; gridsize_y = 12; name = None
            
            #Assigning values different from standard values if they have been entered, 
            data_list = [window_size, gridsize_x, gridsize_y, bombcount, name]

            for i in range(len(IF_list)):
                if IF_list[i].get() != "":
                    #The fourth element should be a string, rest ints. 
                    if i == 4:
                        data_list[i] = IF_list[i].get()
                    else: 
                        try:
                            data_list[i] = int(IF_list[i].get())
                        except:
                            messagebox.showerror('python error', 'Error: please only enter numbers\n in gridsize and window settings!')
                            
                        
                        data_list[i] = int(IF_list[i].get())
                #Avoiding but where standard bombs are too many when only choosing a small gridsize in menu
                elif i == 3 and IF_list[i].get() == "":
                    data_list[i] = int(data_list[1] * data_list[2] * 0.25)
            
            def size_error_controll(data, threshold, default_value,keep_below: bool, error_message: str):
                """Shows an error message with selected error message if data is greater or smaller than threshold (depending on keep_below bool).
                If the data is indeed too large or small returns default_value, otherwise returns original value"""
                if keep_below:
                    if data > threshold:
                        messagebox.showerror('python error', error_message)
                        return default_value
                    else:
                        return data
                
                elif not keep_below:
                    if data < threshold:
                        messagebox.showerror('python error', error_message)
                        return default_value
                    else:
                        return data
            #If data_list[3] (bombcount) is too large
            data_list[3] = size_error_controll(data_list[3], 0.8*data_list[1]*data_list[2], int(0.25*data_list[1]*data_list[2]), True, 
                'Error: do not pick a bombcount above 80 percent of total tiles!\nNow reverting to default bombcount of 25 percent of tiles.')
            #If data_list[0] (window_size) is too large or small
            data_list[0] = size_error_controll(data_list[0], 1000, 500, True, 'Error: You have picked an invalid window size!\nStay inbetween 400 and 1000, defaulting windowsize to 500.')
            data_list[0] = size_error_controll(data_list[0], 400, 500, False, 'Error: You have picked an invalid window size!\nStay inbetween 400 and 1000, defaulting windowsize to 500.')
            for i in range(1, 3):
                data_list[i] = size_error_controll(data_list[i], 40, 20, True, 'You have choosen too large of a gridsize!\nIn order to not crash program is reverting it to 20')
            #In order to avoid a bug where unentered bombcount-data gets to big because gridsize entered was bigger than 40
            if IF_list[3] == "":
                data_list[3] = int(data_list[1]*data_list[2]*0.25)

            #data_list = [window_size, gridsize_x, gridsize_y, bombcount, name]
            
            #Note that window is currently only able to be square
            self.change_size(data_list[0], data_list[0])
            #Creates the underlying minefield with the entered data
            self.GC.new_field(data_list[1], data_list[2], data_list[3], data_list[4])
            #Makes a game_frame, this will in turn access the entered data through the minefield object created in the line above
            self.create_game_frame()
            self.set_current("game")
        
        start_button = Button(menu_frame, text = "Start Game!", background = "#404040", fg ="#000000", borderwidth = 5,font = ("Helvetica", 20) , command = start_game_GUI)
        start_button_width = 200
        start_button.place(x=(self.width - start_button_width)//2, y=self.height//2, width = start_button_width, height = 100)

        info_lbl = Label(menu_frame, text = "Note:\nPlease dont pick a window size below 400 or above 1000.\nGrid width/height should also be keept to below 40.", font = ("Helvetica", 12), just = 'left')
        info_lbl.place(x = 0, y = self.height*7//8, width = self.width//1.5, height = self.height//8)

        self.menu_frame = menu_frame


class Scorekeeper:
    """A temporary data-storing class, meant to be replaced when game has been restared"""
    def __init__(self, name = None) -> None:
        self.time_start = None
        self.time_finish = None
        self.bombs_cleared = 0
        self.name = name
        

class Game_controller:
    """Connects all necessary objects to one another and contains methods accessing these different objects"""
    def __init__(self) -> None:
        #These are set to None as they are determined by user input from the menu window
        self.minefield = None
        self.scoreboard = Scoreboard(game_controller = self)
        self.scorekeeper = None
        
        self.game_ended = False
        
        #Initiates the GUI and sets the current GUI window to a menu window
        self.gui = GUI(500, 500, game_controller = self)
        self.gui.create_menu_frame(); self.gui.set_current("menu"); self.gui.root.mainloop()


    def new_field(self, gridsize_x, gridsize_y, bombcount, name):
        """Creates the minefield and starts the scorekeeper to keep track of game info"""
        self.minefield = Minefield(self ,bombcount, gridsize_x, gridsize_y)
        self.scorekeeper = Scorekeeper(name)
        self.game_ended = False
        

    def reset_score(self):
        """Resets all score data (to be used when game is being restarted)"""
        self.scorekeeper = Scorekeeper(self.scorekeeper.name)
        self.minefield.cleared_coordinates = []
        self.game_ended = False


    def game_over(self, finished: bool, button_dict: dict) -> None:
        """Function should be called when a mine has been struck by the player, different behaviour if level has been failed or completed (finished bool). 
        Creates a game-over window in the specified frame (current_GUI) with information about the played game."""
        
        #Green background to game-over card if level was completed, otherwise red. 
        bg_color = "#631313"
        sb = self.scoreboard
        if finished:
            bg_color = "#257829"
        
        over_frame = Frame(self.gui.current, bg = "#373737", highlightthickness = self.gui.width//60, highlightbackground = bg_color)
        over_frame.place(y = 0, x = self.gui.width//2, width = self.gui.width //2, height = self.gui.height//4)
        over_frame.pack_propagate(False)
        
        self.scorekeeper.time_finish = time.time()
        delta_time = self.scorekeeper.time_finish - self.scorekeeper.time_start
        formated_time = time.strftime("%H:%M:%S", time.gmtime(delta_time))
        if finished:
            self.scoreboard.add()
            text_list = ["Cleared level", formated_time, sb.read(3)]
        elif not finished:
            text_list = ["Failed level", formated_time, sb.read(3)]
        font_base_size = 14 * 500 / min(self.gui.height, self.gui.width)

        score_lbl = Label(over_frame, bg = "#373737", fg = "#FFFFFF", text = f"{text_list[0]} in {text_list[1]}", font = ("Britannic Bold", int(font_base_size * 1.2)))
        scoreboard_lbl = Label(over_frame, bg = "#373737", fg = "#FFFFFF", text = f"{text_list[2]}", font = ("Helvetica", int(font_base_size * 0.8)))
        score_lbl.pack(side = TOP)
        scoreboard_lbl.pack(side = TOP, pady = self.gui.height//24)

        #Goes through all tiles and "clears" them all
        for i in range(1, self.minefield.grid_width + 1):
            for j in range(1, self.minefield.grid_height + 1):
                tile: Tile = self.minefield.tiles[(i, j)]
                button: Frame = button_dict[(i, j)]
                if tile.mined:
                    button.configure(bg = "red")
                elif not tile.mined:
                    #unflaggs the tile and clears it
                    if tile.flagged:
                        tile.flag(button)
                    self.clear_tile((i, j), button_dict, True)
        self.game_ended = True


    def clear_tile(self, coordinates: tuple, button_dict: dict, revealing: bool = False) -> None:
        """Takes coordinates of the tile/button clicked and checks if the corresponding Tile-object is mined.
        If it is mined, "ends" the game by calling game_over function. The reveal bool is to be used when the entire board is to be revealed."""
        button = button_dict[coordinates]
        tile: Tile = self.minefield.tiles[coordinates]
        grid: dict = self.minefield.tiles
        
        def adjacent_bombs() -> int:
            """Returns number (integer) of adjacent bombs (tiles with .mined as true)"""
            nonlocal tile, grid
            x = tile.coord[0]
            y = tile.coord[1]
            bombs_adjacent = 0
            for i in range(x-1, x+1 + 1):
                for j in range(y-1, y+1 + 1):
                    try:
                        if grid[(i, j)].mined:
                            bombs_adjacent += 1
                    #If tile does not exist, for example if tile selected is (1, 1) then (0,0) will be checked.
                    except:
                        pass
            return bombs_adjacent

        #Clicked tile with bomb and without flag
        if tile.mined and not tile.flagged and not self.game_ended:
            button.configure(bg = "red")
            self.game_over(False, button_dict)

        #Clicked tile without bomb and without flag
        elif not tile.mined and not tile.flagged and coordinates not in self.minefield.cleared_coordinates and not self.game_ended:
            button.configure(bg = "green")
            lbl = Label(button, text = f"{adjacent_bombs()}", bg = "green")
            lbl.pack(fill="both", expand = True)
            
            
            #Keeps track of how many tiles have been cleared and calls game_over if all (non-mined) tiles have been identified 
            if not tile.scored:
                tile.scored = True
                self.scorekeeper.bombs_cleared += 1
                #If revealing == True then the game has already ended
                if self.scorekeeper.bombs_cleared >= self.minefield.grid_height * self.minefield.grid_width - self.minefield.bombcount and not revealing:
                    self.game_over(True, button_dict)

            self.minefield.cleared_coordinates.append(coordinates)
            if adjacent_bombs() == 0:
                for i in range (-1, 2):
                    for j in range(-1, 2):
                        new_coords = (tile.coord[0] + i, tile.coord[1] + j)
                        
                        try:
                            #checks tile exists and wont call any errors before mutating list
                            grid[new_coords]
                            if new_coords not in self.minefield.cleared_coordinates:
                                self.clear_tile(new_coords, button_dict, revealing = revealing)
                        except:
                            pass
        #Tile is flagged or game has ended when the tile/button is clicked. 
        else:
            pass 


def main():
    #Initiating a Game_controller object starts the gameplay loop 
    Game_controller()


if __name__ == "__main__":
    main()
